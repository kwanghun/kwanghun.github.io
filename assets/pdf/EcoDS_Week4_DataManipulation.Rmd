---
title: 데이터 분석 기초 - 데이터 파악 및 수정
institute: 환경생태데이터사이언스 실습 \today
output: binb::metropolis
mainfont: KoPubWorldBatang
fontsize: 10pt
---

```{r,setup, include=FALSE}
knitr::opts_chunk$set(cache=FALSE)
```

```{r set-options, include=FALSE}
options(width = 60)
```

# 지난 주 과제 풀이

## 간단한 과제

큐 모듈을 적절히 변형하여 다음과 같은 생태계 지수를 계산할 수 있는 모형을 작성하세요.

1. 현재 생물 종과 각각의 종의 수를 입력하여 Shannon index 구하기. 

2. 새로운 종이 들어왔을 때 각기 다른 생물 종의 숫자 (풍부도), Shannon index (다양성 지수)를 계산 및 출력.

3. 하나의 종이 사라졌을 때 생물 종의 숫자 (풍부도), Shannon index (다양성 지수)를 계산 및 출력.

- Shannon index (다양성): $S = - \sum plog(p)$
- Richness (풍부도): $R$

## 간단한 해결 방법
```{r, eval=F}
CalDiv <- function (){
    q <- c (); qsize <- 0
    Species_in <- function (data){
        q <<- c (q, data)
        qsize <<- qsize + 1
        prob <- q/sum(q)
        Shannon_index <- - sum(prob*log(prob)) 
        return (c(qsize, Shannon_index))
    }
```

## 간단한 해결 방법
```{r, eval=F}
    Species_out <- function (){
        first <- q[1]
        q <<- q[ - 1]
        qsize <<- qsize - 1
        prob <- q/sum(q)
        Shannon_index <- - sum(prob*log(prob)) 
        return (c(qsize, Shannon_index))
    }
    size <- function (){ return (qsize)}
    return ( list (Species_in = Species_in, 
                   Species_out = Species_out,  size = size))
}
```

## 다른 해결 방법
```{r, eval=F}
Diversity <- function(){
    q <- c(); qsize <- 0
    species <- c()
    Species_in <- function(Name, Number){
        q <<- c(q, Number)
        species <<- c(species, Name)
        qsize <<- qsize + 1
        prob <- q/sum(q)
        ShannonIndex <- -sum(prob*log(prob))
        return(list("Richness" = qsize, "Diversity" = ShannonIndex))
    }
```
## 다른 해결 방법 
```{r, eval=F}
    Species_out <- function(Name){
        Out <- q[c(species==Name)]
        q <<- q[!c(species==Name)]
        qsize <<- qsize - 1
        prob <- q/sum(q)
        ShannonIndex <- -sum(prob*log(prob))
        return(list("Out" = Out, "Richness" = qsize,  
                    "Diversity" = ShannonIndex))
    }
    size <- function(){return(qsize)}
    return(list(Species_in = Species_in, 
                Species_out = Species_out, size = size))
}
```

# 오늘의 학습 목표

## 데이터 분석 기초

1. 데이터 호출 및 저장
2. 데이터 구조 및 요약 통계치 확인
3. 데이터에 자료 추가
4. 데이터에 함수 적용
5. 데이터 분리 및 병합  
5. 기초 도표 그리기

# 데이터 호출 및 저장

## 기본 데이터 호출 방법

R에서 주로 이용하는 데이터 형식: 문서 기반 자료

1. **__csv__**: Comma separated values 
2. tsv: tab separated values
3. dat: csv 형태이거나 tsv 형태일 가능성이 있음
4. 공백으로 구분된 자료, 특정 기호로 구분된 자료

## 기본 데이터 호출 방법
R 기본 내장 함수를 이용한 자료 호출
```{r, eval=F}
# ReadData <- read.table("/path/to/the/file", sep = " ", header = T) 

Read_csv_1 <- read.table("./Data/KMA_20190916_0922.csv", sep=",", 
                       header=T)
Read_tsv_1 <- read.table("./Data/MeteorologicalData.tsv", sep="\t", 
                       header=T)
Read_dat_1 <- read.table("./Data/MeteorologicalData.dat", sep="\t", 
                       header=T)
```
**csv** 파일은 `read.csv()` 명령어를 이용하여 호출
```{r}
Read_csv <- read.csv("./Data/KMA_20190916_0922.csv")
```

## 파일 호출 옵션

* `header`: 데이터에 열이름이 있는지 확인 (TRUE, FALSE)
* `na.strings`: NA로 지정된 값이 있으면 명시 (TRUE, FALSE)
* `stringAsFactors`: 문자열을 팩터로 읽을 것인지 판단 (TRUE, FALSE)


## 기본 데이터 저장 방법

* 데이터 호출 방법과 유사
```{r, eval=F}
write.table(Data, "/path/to/the/file/", sep = " ", 
            col.names = T, row.names = T) 
write.csv(Read_csv, "./Data/KMA_20190916_0922_edited.csv", 
          row.names=F)
# Check whether file is in the folder or not
```

* `col.names`: 열이름을 데이터와 함께 저장
* `row.names`: 행이름을 데이터와 함께 저장 (행 이름이 없으면 행의 순서를 행이름으로 저장)

## 작업 공간에 있는 데이터 바이너리로 저장 및 호출

* 작업 공간에 있는 객체를 저장할 때
```{r, eval=F}
save(Data, "/path/to/the/file/") 
```
* 작업 공간에 있는 모든 데이터를 저장
```{r, eval=F}
save.image(Data, "/path/to/the/file/") 
```
* 저장한 데이터 호출
```{r, eval=F}
load("/path/to/the/file")
```

# 데이터 구조 및 요약 통계치 확인

## 데이터의 구조를 직접 확인하는 방법
```{r}
head(Read_csv) # Check first 6 rows of the data 
```

## 데이터의 구조를 직접 확인하는 방법
```{r}
tail(Read_csv) # Check last 6 rows of the data 
```

## 명령어를 이용하여 데이터 구조 확인 방법
```{r}
class(Read_csv) # Check the data class 
str(Read_csv) # Check the structure of data 
```

## 데이터의 기본 속성 확인 후 변수형 수정
위 데이터에서 ID는 기상대의 고유 번호를 뜻하므로 factor여야 하고, Time 또한 시간이므로 시간 자료로 형 변환해야한다.
```{r}
# integer to factor
Read_csv$ID <- as.factor(Read_csv$ID)
Read_csv$Time <- strptime(Read_csv$Time, format=c("%Y-%m-%d %H:%M"))
str(Read_csv$ID)
str(Read_csv$Time)
```

## `summary` 함수를 이용한 전체 데이터 요약 통계 확인
```{r}
summary(Read_csv)
```


# 데이터에 자료 추가

## 데이터에 새로운 열 추가

새로운 행을 만들고 강우량이 기록된 행은 "Rain", 그리고 그렇지 않은 곳은 "No Rain" 이라고 기록하기
```{r}
Read_csv$RainOrNot <- 
    ifelse( is.na( Read_csv$Precipitation ), "No Rain", "Rain" )  
head(Read_csv$RainOrNot)
tail(Read_csv$RainOrNot)
```

## 주어진 벡터를 이용한 열 추가
```{r}
Column_Data <- data.frame("Country" = rep("Korea", nrow(Read_csv)), 
                           "Season" = rep("Autumn", nrow(Read_csv)))
head(Column_Data, 3)
ColumnBind <- cbind(Read_csv, Column_Data); head(ColumnBind, 2)
```

## 주어진 벡터를 이용한 행 추가
```{r}
Row_Data <- Read_csv[1:3, ] # Crop first 6 rows of Read_csv data
RowBind <- rbind(Read_csv, Row_Data); tail(RowBind, 6)
```

# 데이터에 함수 적용

## apply 계열 함수

![](../Figures/EcoDS_Week4_applys.png)

[출처: 서명구 (2014). R을 이용한 데이터 처리 & 분석 실무. 길벗](https://thebook.io/006723/ch03/03/01/)

## apply
```{r}
ApplyTest <- RowBind
# Apply apply function to rows
#apply(ApplyTest[,c(3:6)], 1, FUN=sum) # 1: by row, 2: by column
# Apply apply function to each column from 3 to 6.
apply(ApplyTest[,c(3:6)], 2, FUN=sum) # 1: by row, 2: by column
apply(ApplyTest[,c(3:6)], 2, FUN=sum, na.rm=T)
apply(ApplyTest[,c(3:6)], 2, FUN=function(x){sum(x, na.rm=T)})
```

## lapply와 sapply
```{r}
lapply(ApplyTest[,c(3:5)], FUN=sum) 
sapply(ApplyTest[,c(3:5)], FUN=sum) 
```

## lapply와 sapply
```{r}
lapply(ApplyTest[,c(3:5)], FUN=sum, na.rm=T)
sapply(ApplyTest[,c(3:5)], FUN=sum, na.rm=T)
```

## lapply
```{r}
lapply(1:3, FUN=function(x){x*2})

unlist(lapply(1:3, FUN=function(x){x*2}))
```

## tapply
```{r}
tapply(ApplyTest$WindVelocity, ApplyTest$RainOrNot, 
       FUN = mean, na.rm = T)
tapply(ApplyTest$Temperature, ApplyTest$RainOrNot, 
       FUN = mean, na.rm = T)
```

# 데이터 분리 및 병합

## 데이터 분리 및 병합

![](../Figures/EcoDS_Week4_SubsetMerge.png)

[출처: 서명구 (2014). R을 이용한 데이터 처리 & 분석 실무. 길벗](https://thebook.io/006723/ch03/03/01/)

## split
split 함수는 특정 팩터로 정해진 열의 요소 별로 자료를 나눈 후 리스트 형식으로 저장한다.
```{r}
SplitResult <- split(Read_csv, Read_csv$ID)
head(SplitResult)
```

## subset
subset 함수는 특정 조건에 맞는 자료들을 선택하여 추출한다.
```{r}
SubsetResult <- subset(Read_csv, ID==90, 
                       select=c("ID", "Time", "WindDirection"))
head(SubsetResult)
```

## merge
두 개의 데이터 프레임을 공통된 요소를 기준으로 병합한다.
```{r}
# Read station name
stnName <- read.csv("./Data/stnInfo_20190923231722.csv", 
                    fileEncoding="euc-kr") 
MergedData <- merge(Read_csv, stnName, by.x = c("ID"), by.y=c("지점"))
head(MergedData)
```

# 기타 다양한 데이터 처리 함수

## 데이터 정렬 (sort와 order)
sort 함수는 벡터를 정렬한 값을 반환하고 order 함수는 벡터를 정렬했을 때 순서를 반환한다.
즉 하나의 벡터를 정렬하고자 하면 sort 함수를 쓰고 데이터 프레임 전체를 특정 열에 대하여 정렬하고자 할 때에는 order 함수를 쓴다.
```{r}
x <- rnorm(5, 10, 10)
x
sort(x)
order(x)
```

## 데이터 정렬 (sort와 order)
```{r}
sort(x, decreasing=T)
order(x, decreasing=T)
Read_csv_sorted <- 
    Read_csv[order(as.numeric(as.character(Read_csv$ID)), 
                   decreasing = T),]
head(Read_csv_sorted)
```

## 원하는 조건을 가진 원소의 위치
which, which.max, which.min 함수는 각각 조건에 맞는 원소의 위치와 최대, 혹은 최소 값의 위치를 알려준다.
```{r}
# Location of elements whose temperature are larger than 30
which(Read_csv$Temperature > 30) 
which.max(Read_csv$Temperature) # Location of the maximum value
which.min(Read_csv$Temperature) # Location of the minimum value
```

## 원하는 조건을 가진 원소의 위치
```{r}
# Extract rows whose temperature is larger than 30
# Read_csv[which(Read_csv$Temperature > 30 ), ]
 # Extract a row with the maximum temperature
Read_csv[which.max(Read_csv$Temperature),]
# Extract a row with the minimum temperature
Read_csv[which.min(Read_csv$Temperature),] 
```

# 기초 도표 그리기

## 기초 도표 그리기
`plot` 함수를 사용하면 기본적인 도표를 작성할 수 있다.
```{r}
# Basic usage
# plot(x = X_value, y = Y_value, type = c("p", "l", "b"), 
#      xlab = "X label", ylab = "Y label", main = "Title", 
#      col = "red")
# Using relationship
# plot( y_value ~ x_value, data = "Data") 
```

## 기초 도표 그리기
```{r}
TempID90 <- subset(Read_csv, ID==90, 
                   select=c(Time, Temperature, WindVelocity))
plot(x = TempID90$Time, y = TempID90$Temperature,
     type="b", col="red")  
```

## 기초 도표 그리기
```{r}
TempID90$Time <- as.POSIXct(TempID90$Time)
plot(WindVelocity ~ Time, data = TempID90, 
     type = "b", pch=24, lty = 3)  
```

## 기초 도표 그리기
```{r}
y <- x <- c(1:25)
plot(y ~ x, type = "b", pch=x, col=x, lty=3, cex=x/5)
```

## 기초 도표 그리기
```{r}
plot(y ~ x, type = "b", pch=x, col=x, lty=3, cex=x/5)
points(2*y ~ x, type = "b", pch=x, col=x, lty=4, cex=x/5)
points(3*y ~ x, type = "b", pch=x, col=x, lty=1, cex=x/5)
```






